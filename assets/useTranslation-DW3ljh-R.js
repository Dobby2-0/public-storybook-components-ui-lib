import{r as f}from"./index-DRjF_FHU.js";import{I as v,R as P}from"./context-BLxVKTzt.js";const $=(...e)=>{console!=null&&console.warn&&(g(e[0])&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e))},H={},b=(...e)=>{g(e[0])&&H[e[0]]||(g(e[0])&&(H[e[0]]=new Date),$(...e))},O=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},S=(e,n,s)=>{e.loadNamespaces(n,O(e,s))},M=(e,n,s,a)=>{if(g(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return S(e,s,a);s.forEach(p=>{e.options.ns.indexOf(p)<0&&e.options.ns.push(p)}),e.loadLanguages(n,O(e,a))},q=(e,n,s={})=>!n.languages||!n.languages.length?(b("i18n.languages were undefined or empty",n.languages),!0):n.hasLoadedNamespace(e,{lng:s.lng,precheck:(a,p)=>{var t;if(((t=s.bindI18n)==null?void 0:t.indexOf("languageChanging"))>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!p(a.isLanguageChangingTo,e))return!1}}),g=e=>typeof e=="string",A=e=>typeof e=="object"&&e!==null,B=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,W={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"©","&#169;":"©","&reg;":"®","&#174;":"®","&hellip;":"…","&#8230;":"…","&#x2F;":"/","&#47;":"/"},G=e=>W[e],J=e=>e.replace(B,G);let K={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:J};const U=()=>K;let Y;const Q=()=>Y,X=(e,n)=>{const s=f.useRef();return f.useEffect(()=>{s.current=e},[e,n]),s.current},j=(e,n,s,a)=>e.getFixedT(n,s,a),Z=(e,n,s,a)=>f.useCallback(j(e,n,s,a),[e,n,s,a]),D=(e,n={})=>{var R,z,F,L;const{i18n:s}=n,{i18n:a,defaultNS:p}=f.useContext(v)||{},t=s||a||Q();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new P),!t){b("You will need to pass in an i18next instance by using initReactI18next");const i=(c,l)=>g(l)?l:A(l)&&g(l.defaultValue)?l.defaultValue:Array.isArray(c)?c[c.length-1]:c,r=[i,{},!1];return r.t=i,r.i18n={},r.ready=!1,r}(R=t.options.react)!=null&&R.wait&&b("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const m={...U(),...t.options.react,...n},{useSuspense:T,keyPrefix:x}=m;let o=e||p||((z=t.options)==null?void 0:z.defaultNS);o=g(o)?[o]:o||["translation"],(L=(F=t.reportNamespaces).addUsedNamespaces)==null||L.call(F,o);const u=(t.isInitialized||t.initializedStoreOnce)&&o.every(i=>q(i,t,m)),k=Z(t,n.lng||null,m.nsMode==="fallback"?o:o[0],x),C=()=>k,w=()=>j(t,n.lng||null,m.nsMode==="fallback"?o:o[0],x),[E,y]=f.useState(C);let h=o.join();n.lng&&(h=`${n.lng}${h}`);const I=X(h),d=f.useRef(!0);f.useEffect(()=>{const{bindI18n:i,bindI18nStore:r}=m;d.current=!0,!u&&!T&&(n.lng?M(t,n.lng,o,()=>{d.current&&y(w)}):S(t,o,()=>{d.current&&y(w)})),u&&I&&I!==h&&d.current&&y(w);const c=()=>{d.current&&y(w)};return i&&(t==null||t.on(i,c)),r&&(t==null||t.store.on(r,c)),()=>{d.current=!1,t&&(i==null||i.split(" ").forEach(l=>t.off(l,c))),r&&t&&r.split(" ").forEach(l=>t.store.off(l,c))}},[t,h]),f.useEffect(()=>{d.current&&u&&y(C)},[t,x,u]);const N=[E,t,u];if(N.t=E,N.i18n=t,N.ready=u,u||!u&&!T)return N;throw new Promise(i=>{n.lng?M(t,n.lng,o,()=>i()):S(t,o,()=>i())})};export{D as u};
