import{r as f}from"./index-DRjF_FHU.js";import{I as k,R as v}from"./context-BLxVKTzt.js";const P=(...e)=>{console!=null&&console.warn&&(g(e[0])&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e))},L={},b=(...e)=>{g(e[0])&&L[e[0]]||(g(e[0])&&(L[e[0]]=new Date),P(...e))},M=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},S=(e,n,s)=>{e.loadNamespaces(n,M(e,s))},H=(e,n,s,a)=>{if(g(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return S(e,s,a);s.forEach(p=>{e.options.ns.indexOf(p)<0&&e.options.ns.push(p)}),e.loadLanguages(n,M(e,a))},$=(e,n,s={})=>!n.languages||!n.languages.length?(b("i18n.languages were undefined or empty",n.languages),!0):n.hasLoadedNamespace(e,{lng:s.lng,precheck:(a,p)=>{var t;if(((t=s.bindI18n)==null?void 0:t.indexOf("languageChanging"))>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!p(a.isLanguageChangingTo,e))return!1}}),g=e=>typeof e=="string",q=e=>typeof e=="object"&&e!==null,A=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,B={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"©","&#169;":"©","&reg;":"®","&#174;":"®","&hellip;":"…","&#8230;":"…","&#x2F;":"/","&#47;":"/"},W=e=>B[e],G=e=>e.replace(A,W);let J={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:G};const K=()=>J;let U;const Y=()=>U,Q=(e,n)=>{const s=f.useRef();return f.useEffect(()=>{s.current=e},[e,n]),s.current},O=(e,n,s,a)=>e.getFixedT(n,s,a),X=(e,n,s,a)=>f.useCallback(O(e,n,s,a),[e,n,s,a]),V=(e,n={})=>{var R,z,F;const{i18n:s}=n,{i18n:a,defaultNS:p}=f.useContext(k)||{},t=s||a||Y();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new v),!t){b("You will need to pass in an i18next instance by using initReactI18next");const i=(c,l)=>g(l)?l:q(l)&&g(l.defaultValue)?l.defaultValue:Array.isArray(c)?c[c.length-1]:c,r=[i,{},!1];return r.t=i,r.i18n={},r.ready=!1,r}(R=t.options.react)!=null&&R.wait&&b("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const m={...K(),...t.options.react,...n},{useSuspense:T,keyPrefix:x}=m;let o=e;o=g(o)?[o]:o||["translation"],(F=(z=t.reportNamespaces).addUsedNamespaces)==null||F.call(z,o);const u=(t.isInitialized||t.initializedStoreOnce)&&o.every(i=>$(i,t,m)),j=X(t,n.lng||null,m.nsMode==="fallback"?o:o[0],x),C=()=>j,w=()=>O(t,n.lng||null,m.nsMode==="fallback"?o:o[0],x),[E,y]=f.useState(C);let h=o.join();n.lng&&(h=`${n.lng}${h}`);const I=Q(h),d=f.useRef(!0);f.useEffect(()=>{const{bindI18n:i,bindI18nStore:r}=m;d.current=!0,!u&&!T&&(n.lng?H(t,n.lng,o,()=>{d.current&&y(w)}):S(t,o,()=>{d.current&&y(w)})),u&&I&&I!==h&&d.current&&y(w);const c=()=>{d.current&&y(w)};return i&&(t==null||t.on(i,c)),r&&(t==null||t.store.on(r,c)),()=>{d.current=!1,t&&(i==null||i.split(" ").forEach(l=>t.off(l,c))),r&&t&&r.split(" ").forEach(l=>t.store.off(l,c))}},[t,h]),f.useEffect(()=>{d.current&&u&&y(C)},[t,x,u]);const N=[E,t,u];if(N.t=E,N.i18n=t,N.ready=u,u||!u&&!T)return N;throw new Promise(i=>{n.lng?H(t,n.lng,o,()=>i()):S(t,o,()=>i())})};export{V as u};
